import * as Crypto from 'expo-crypto';
import * as Random from 'expo-random';
import { Buffer } from 'buffer';
import { DiscoveryDocument, makeRedirectUri } from 'expo-auth-session';
import * as AuthSession from 'expo-auth-session';
import { Platform } from 'react-native';
import * as WebBrowser from 'expo-web-browser';
import * as Linking from 'expo-linking';
WebBrowser.maybeCompleteAuthSession();

export function generateShortUUID(): string {
  return Math.random().toString(36).substring(2, 15);
}

interface StringMap {
  [key: string]: string;
}
interface AuthParams {
  state: string;
  codeVerifier: string;
  authUrl: string;
}
export function toQueryString(params: StringMap): string {
  return (
    '?' +
    Object.entries(params)
      .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)
      .join('&')
  );
}

export function URLEncode(str: string): string {
  return str.replace(/\+/g, '-').replace(/\//g, '_').replace(/[=]/g, '');
}

export async function sha256(buffer: string): Promise<string> {
  return await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, buffer, { encoding: Crypto.CryptoEncoding.BASE64 });
}
export async function getAuthParams(clientId: string, redirectUri: string, discovery: DiscoveryDocument): Promise<AuthParams> {
  const state = generateShortUUID();
  const randomBytes = await Random.getRandomBytesAsync(32);
  const base64String = Buffer.from(randomBytes).toString('base64');
  const codeVerifier = URLEncode(base64String);
  const codeChallengs = URLEncode(await sha256(codeVerifier));
  const authenticationOptions = {
    response_type: 'code',
    code_challenge: codeChallengs,
    code_challenge_method: 'S256',
    scope: ['openid', 'profile', 'email', 'address', 'phone', 'offline_access'].join(' '),
    state,
    client_id: clientId,
    redirect_uri: redirectUri,
  };
  const authUrl = discovery.discoveryDocument?.authorization_endpoint + toQueryString(authenticationOptions);
  return {
    state,
    codeVerifier,
    authUrl,
  };
}

export async function exchangeCodeForToken(
  clientId: string,
  redirectUri: string,
  discovery: DiscoveryDocument,
  code: string,
  codeVerifier: string,
) {
  return AuthSession.exchangeCodeAsync(
    {
      code,
      clientId,
      redirectUri,
      extraParams: {
        code_verifier: codeVerifier,
      },
    },
    discovery,
  );
}

export function extractCodeOrThrow(result: AuthSession.AuthSessionResult, state: string): string {
  if (result.type === 'success' && result.params && result.params.code && result.params.state === state) {
    return result.params.code;
  } else {
    throw result;
  }
}
export async function getDiscovery(issuer: string): Promise<DiscoveryDocument> {
  return AuthSession.fetchDiscoveryAsync(issuer);
}

export async function doOauthPkceFlow(clientId: string, issuer: string): Promise<AuthSession.TokenResponse> {
  // whether or not to use the expo proxy
  const useProxy = Platform.select({ web: false, default: true });
  // set up redirect uri
  const redirectUri = makeRedirectUri({ useProxy });
  // fetch oauth issuer information from discovery endpoint
  const discovery = await getDiscovery(issuer);
  // set up the IDP url, prepare codeVerifier and state
  const { authUrl, codeVerifier, state } = await getAuthParams(clientId, redirectUri, discovery);
  // redirect to the IDP
  const authResult = await AuthSession.startAsync({ authUrl, returnUrl: Linking.makeUrl('/') });
  // check the response for success/failure
  const code = extractCodeOrThrow(authResult, state);
  // exchange the received code for an access token
  return exchangeCodeForToken(clientId, redirectUri, discovery, code, codeVerifier);
}
